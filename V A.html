<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Vetenuge Art Software</title>
  <style>
    /* Reset default margins and set background color */
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      width: 100%;
      background-color: #000;

      /* Center the canvas container using Flexbox */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Container to hold canvases */
    #canvasContainer {
      position: relative;
    }

    /* Main canvas and overlay canvas */
    #canvas, #overlayCanvas {
      display: block;
    }

    #canvas {
      background: #fff;
      cursor: none;
      z-index: 1;
    }

    /* Overlay canvas for brush preview and shape drawing */
    #overlayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 2;
    }

    /* Style the menu */
    #menu {
      position: fixed;
      bottom: -65%;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 600px;
      background: rgba(0, 0, 0, 0.9);
      color: #fff;
      padding: 15px;
      box-sizing: border-box;
      border-radius: 10px 10px 0 0;
      transition: bottom 0.6s ease-in-out;
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 3;
    }

    /* Slide the menu up when active */
    #menu.active {
      bottom: 10%;
    }

    /* Style for menu rows */
    .menu-row {
      display: flex;
      justify-content: space-between;
      width: 100%;
      margin-bottom: 10px;
    }

    .menu-item {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 5px;
    }

    .menu-item input[type="number"],
    .menu-item input[type="text"],
    .menu-item input[type="color"] {
      width: 100%;
      padding: 8px;
      box-sizing: border-box;
      height: 40px;
    }

    /* Ensure all input boxes are equally tall */
    .menu-item input {
      height: 40px;
    }

    .center-label {
      text-align: center;
      font-size: 24px;
      margin-bottom: 5px;
    }

    /* Style the tool buttons */
    .tool-button {
      flex: 1;
      margin: 5px;
      padding: 10px 0;
      background-color: #1e90ff;
      border: none;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
      border-radius: 5px;
      text-align: center;
    }

    .tool-button:hover {
      background-color: #63b3ff;
    }

    .tool-button.selected {
      background-color: #63b3ff;
    }

    /* Style the save button (floppy disk emoji) */
    #saveButton {
      width: 50px;
      padding: 10px;
      margin-left: 5px;
      background-color: #1e90ff;
      border: none;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
      border-radius: 5px;
      text-align: center;
    }

    #saveButton:hover {
      background-color: #63b3ff;
    }

    /* Style the button container */
    #buttonContainer {
      display: flex;
      justify-content: space-between;
      width: 100%;
      margin-top: 10px;
    }

    #buttonContainer button {
      flex: 1;
      margin: 5px;
      padding: 10px 20px;
      background-color: #1e90ff;
      border: none;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      border-radius: 5px;
      text-align: center;
    }

    #buttonContainer button:hover {
      background-color: #63b3ff;
    }
  </style>
</head>
<body>
  <div id="canvasContainer">
    <canvas id="canvas"></canvas>
    <canvas id="overlayCanvas"></canvas>
  </div>
  <div id="menu">
    <!-- Brush Color, Size, Canvas Width, Canvas Height -->
    <div class="menu-row">
      <div class="menu-item">
        <label for="colorPicker" class="center-label">üé®</label>
        <input type="color" id="colorPicker" value="#000000">
      </div>
      <div class="menu-item">
        <label for="sizeInput" class="center-label">‚úèÔ∏è</label>
        <input type="number" id="sizeInput" value="5" min="1" max="100" step="1">
      </div>
      <div class="menu-item">
        <label for="widthInput" class="center-label">‚ÜîÔ∏è</label>
        <input type="number" id="widthInput" value="800" min="1" step="1">
      </div>
      <div class="menu-item">
        <label for="heightInput" class="center-label">‚ÜïÔ∏è</label>
        <input type="number" id="heightInput" value="600" min="1" step="1">
      </div>
    </div>

    <!-- Tool Buttons -->
    <div class="menu-row">
      <button class="tool-button selected" id="tool-brush" title="Brush">üñåÔ∏è</button>
      <button class="tool-button" id="tool-line" title="Line">üìè</button>
      <button class="tool-button" id="tool-rectangle" title="Rectangle">‚ñ≠</button>
      <button class="tool-button" id="tool-circle" title="Circle">‚ö™</button>
      <button class="tool-button" id="tool-text" title="Text">üî§</button>
    </div>

    <!-- File Name and Save Painting -->
    <div class="menu-row">
      <div class="menu-item" style="flex: 1;">
        <label for="fileNameInput" class="center-label">üìù</label>
        <input type="text" id="fileNameInput" placeholder="File Name">
      </div>
      <button id="saveButton">üíæ</button>
    </div>

    <!-- Apply Changes and Clear Canvas Buttons -->
    <div class="menu-row" id="buttonContainer">
      <button id="applyButton">Apply Changes</button>
      <button id="clearButton">Clear Canvas</button>
    </div>
  </div>
  <script>
    // Get references to DOM elements
    const canvasContainer = document.getElementById('canvasContainer');
    const canvas = document.getElementById('canvas');
    const overlayCanvas = document.getElementById('overlayCanvas');
    const menu = document.getElementById('menu');
    const colorPicker = document.getElementById('colorPicker');
    const sizeInput = document.getElementById('sizeInput');
    const widthInput = document.getElementById('widthInput');
    const heightInput = document.getElementById('heightInput');
    const applyButton = document.getElementById('applyButton');
    const clearButton = document.getElementById('clearButton');
    const saveButton = document.getElementById('saveButton');
    const fileNameInput = document.getElementById('fileNameInput');

    // Tool buttons
    const toolBrush = document.getElementById('tool-brush');
    const toolLine = document.getElementById('tool-line');
    const toolRectangle = document.getElementById('tool-rectangle');
    const toolCircle = document.getElementById('tool-circle');
    const toolText = document.getElementById('tool-text');

    const ctx = canvas.getContext('2d');
    const overlayCtx = overlayCanvas.getContext('2d');

    // Variables for drawing
    let drawing = false;
    let cursorX = 0;
    let cursorY = 0;

    // Current brush settings
    let currentBrushSize = parseInt(sizeInput.value, 10) || 5;
    let currentBrushColor = colorPicker.value;

    // Current tool: default is 'brush'
    let currentTool = 'brush';

    // Undo and Redo stacks
    let undoStack = [];
    let redoStack = [];
    const maxUndoStackSize = 20; // Reduced stack size to 20

    let ctrlZPressed = false; // Flag for Ctrl+Z
    let ctrlYPressed = false; // Flag for Ctrl+Y

    // Initialize canvas size
    function initializeCanvasSize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      overlayCanvas.width = canvas.width;
      overlayCanvas.height = canvas.height;

      widthInput.value = canvas.width;
      heightInput.value = canvas.height;

      // Save the initial state
      saveCanvasState();
    }

    initializeCanvasSize();

    // Adjust canvas position when window resizes without changing its size
    function adjustCanvasPosition() {
      // No action needed because Flexbox centers the canvasContainer
      // Just redraw the brush preview to update its position
      drawBrushPreview();
    }

    window.addEventListener('resize', () => {
      adjustCanvasPosition();
    });

    // Update the cursor position and draw the brush preview
    function updateCursorPosition(event) {
      const rect = overlayCanvas.getBoundingClientRect();
      cursorX = event.clientX - rect.left;
      cursorY = event.clientY - rect.top;

      drawBrushPreview();
    }

    function drawBrushPreview() {
      // Clear the overlay canvas
      overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

      // Don't draw the brush preview while drawing or if not using brush tool
      if (drawing || currentTool !== 'brush' || menuVisible) return;

      // Draw the brush preview circle
      const brushSize = currentBrushSize;
      const color = currentBrushColor;

      overlayCtx.beginPath();
      overlayCtx.arc(cursorX, cursorY, brushSize / 2, 0, Math.PI * 2);
      overlayCtx.fillStyle = color;
      overlayCtx.fill();
    }

    // Toggle menu visibility when spacebar is pressed
    let menuVisible = false;
    document.addEventListener('keydown', (event) => {
      if (event.code === 'Space') {
        event.preventDefault(); // Prevent default actions
        menu.classList.toggle('active');
        menuVisible = !menuVisible;

        // Disable drawing when menu is open
        if (menuVisible) {
          overlayCanvas.style.pointerEvents = 'none';
          drawBrushPreview(); // Hide the brush preview
        } else {
          overlayCanvas.style.pointerEvents = 'auto';
          drawBrushPreview(); // Show the brush preview
        }
      }

      // Undo and Redo functionality
      if ((event.ctrlKey || event.metaKey) && !menuVisible) {
        if (event.code === 'KeyZ') {
          if (!ctrlZPressed) {
            event.preventDefault();
            undo();
            ctrlZPressed = true;
          }
        } else if (event.code === 'KeyY') {
          if (!ctrlYPressed) {
            event.preventDefault();
            redo();
            ctrlYPressed = true;
          }
        }
      }
    });

    document.addEventListener('keyup', (event) => {
      if (event.code === 'KeyZ') {
        ctrlZPressed = false;
      } else if (event.code === 'KeyY') {
        ctrlYPressed = false;
      }
    });

    // Hide the menu if the user clicks outside of it
    document.addEventListener('click', (e) => {
      if (menuVisible && !menu.contains(e.target)) {
        menu.classList.remove('active');
        menuVisible = false;
        overlayCanvas.style.pointerEvents = 'auto';
        drawBrushPreview();
      }
    });

    // Apply changes from the menu
    applyButton.addEventListener('click', () => {
      // Save the current state before making changes
      saveCanvasState();

      // Retrieve and validate brush size
      let brushSizeInput = parseInt(sizeInput.value, 10);
      brushSizeInput = Math.max(1, Math.min(brushSizeInput, 100));
      sizeInput.value = brushSizeInput;

      // Retrieve brush color
      let brushColorInput = colorPicker.value;

      // Apply pending brush settings
      currentBrushSize = brushSizeInput;
      currentBrushColor = brushColorInput;

      // Retrieve and validate canvas size
      let newWidth = parseInt(widthInput.value, 10);
      let newHeight = parseInt(heightInput.value, 10);

      const maxWidth = window.innerWidth;
      const maxHeight = window.innerHeight;

      let sizeAdjusted = false;

      if (newWidth > maxWidth) {
        newWidth = maxWidth;
        sizeAdjusted = true;
      }

      if (newHeight > maxHeight) {
        newHeight = maxHeight;
        sizeAdjusted = true;
      }

      if (newWidth > 0 && newHeight > 0) {
        // Save the current canvas content
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        // Update canvas dimensions
        canvas.width = newWidth;
        canvas.height = newHeight;
        overlayCanvas.width = newWidth;
        overlayCanvas.height = newHeight;

        // Restore the canvas content
        ctx.putImageData(imageData, 0, 0);

        // Update the width and height inputs with the adjusted values
        widthInput.value = canvas.width;
        heightInput.value = canvas.height;

        if (sizeAdjusted) {
          alert('Canvas size cannot exceed the viewport dimensions. The canvas has been adjusted accordingly.');
        }

        menu.classList.remove('active'); // Hide the menu after applying changes
        menuVisible = false;
        overlayCanvas.style.pointerEvents = 'auto';

        // Redraw the brush preview
        drawBrushPreview();
      } else {
        alert('Please enter positive values for width and height.');
      }
    });

    // Save the painting
    saveButton.addEventListener('click', () => {
      let fileName = fileNameInput.value.trim() || 'my_painting';
      let link = document.createElement('a');
      link.download = fileName + '.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    // Prevent input values from exceeding the defined ranges
    function enforceInputRanges() {
      // Enforce brush size range
      sizeInput.addEventListener('input', () => {
        let value = parseInt(sizeInput.value, 10) || 1;
        value = Math.max(1, Math.min(value, 100));
        sizeInput.value = value;
      });
    }

    enforceInputRanges();

    // Clear the canvas
    clearButton.addEventListener('click', () => {
      saveCanvasState();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    });

    // Tool selection
    function selectTool(toolName) {
      currentTool = toolName;
      // Highlight the selected tool
      document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('selected'));
      document.getElementById('tool-' + toolName).classList.add('selected');
      drawBrushPreview();
    }

    // Event listeners for tool buttons
    toolBrush.addEventListener('click', () => selectTool('brush'));
    toolLine.addEventListener('click', () => selectTool('line'));
    toolRectangle.addEventListener('click', () => selectTool('rectangle'));
    toolCircle.addEventListener('click', () => selectTool('circle'));
    toolText.addEventListener('click', () => selectTool('text'));

    // Initialize with brush tool selected
    selectTool('brush');

    // Variables for shape drawing
    let startX, startY;
    let movedDuringDraw = false; // Track if the cursor moved during drawing

    // Drawing functions
    function startDrawing(event) {
      if (menuVisible) return;

      drawing = true;
      updateCursorPosition(event);

      startX = cursorX;
      startY = cursorY;
      movedDuringDraw = false; // Reset movement flag

      if (currentTool === 'line' || currentTool === 'rectangle' || currentTool === 'circle') {
        overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      } else if (currentTool === 'text') {
        saveCanvasState();

        let userText = prompt('Enter text:');
        if (userText) {
          ctx.fillStyle = currentBrushColor;
          ctx.font = currentBrushSize * 2 + 'px sans-serif';
          ctx.fillText(userText, startX, startY);
          saveCanvasState(); // Save after adding text
        }
        drawing = false;
      } else if (currentTool === 'brush') {
        saveCanvasState();

        // For brush tool
        ctx.beginPath();
        ctx.moveTo(cursorX, cursorY);

        // Draw a dot if the user clicks without moving
        ctx.strokeStyle = currentBrushColor;
        ctx.lineWidth = currentBrushSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineTo(cursorX, cursorY);
        ctx.stroke();
      }
    }

    function draw(event) {
      if (!drawing || menuVisible) return;
      updateCursorPosition(event);

      if (startX !== cursorX || startY !== cursorY) {
        movedDuringDraw = true;
      }

      if (currentTool === 'line' || currentTool === 'rectangle' || currentTool === 'circle') {
        overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

        overlayCtx.strokeStyle = currentBrushColor;
        overlayCtx.lineWidth = currentBrushSize;
        overlayCtx.lineCap = 'round';
        overlayCtx.lineJoin = 'round';

        if (currentTool === 'line') {
          overlayCtx.beginPath();
          overlayCtx.moveTo(startX, startY);
          overlayCtx.lineTo(cursorX, cursorY);
          overlayCtx.stroke();
        } else if (currentTool === 'rectangle') {
          overlayCtx.beginPath();
          overlayCtx.rect(startX, startY, cursorX - startX, cursorY - startY);
          overlayCtx.stroke();
        } else if (currentTool === 'circle' && movedDuringDraw) {
          overlayCtx.beginPath();
          let radius = Math.hypot(cursorX - startX, cursorY - startY);
          overlayCtx.arc(startX, startY, radius, 0, Math.PI * 2);
          overlayCtx.stroke();
        }
      } else if (currentTool === 'brush') {
        ctx.strokeStyle = currentBrushColor;
        ctx.lineWidth = currentBrushSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        ctx.lineTo(cursorX, cursorY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(cursorX, cursorY);
      }
    }

    function stopDrawing() {
      if (!drawing) return;
      drawing = false;

      if (currentTool === 'line' || currentTool === 'rectangle' || currentTool === 'circle') {
        if (!movedDuringDraw) {
          // Do not draw anything if the mouse didn't move
          overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
          return;
        }

        saveCanvasState();

        ctx.drawImage(overlayCanvas, 0, 0);
        overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      }

      drawBrushPreview();
    }

    // Undo and Redo functionality
    function saveCanvasState() {
      // Limit the undo stack size to 20
      if (undoStack.length >= 20) {
        undoStack.shift();
      }
      // Save current canvas state
      undoStack.push(canvas.toDataURL());

      // Clear redo stack on new action
      redoStack = [];
    }

    function undo() {
      if (undoStack.length > 1) {
        redoStack.push(undoStack.pop());
        let lastState = undoStack[undoStack.length - 1];
        restoreCanvasState(lastState);
      } else if (undoStack.length === 1) {
        // Clear canvas if only initial state remains
        redoStack.push(undoStack.pop());
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    }

    function redo() {
      if (redoStack.length > 0) {
        let restoredState = redoStack.pop();
        undoStack.push(restoredState);
        restoreCanvasState(restoredState);
      }
    }

    function restoreCanvasState(state) {
      let img = new Image();
      img.src = state;
      img.onload = function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);
      };
    }

    // Event listeners for drawing
    overlayCanvas.addEventListener('mousemove', updateCursorPosition);
    overlayCanvas.addEventListener('mousedown', startDrawing);
    overlayCanvas.addEventListener('mousemove', draw);
    overlayCanvas.addEventListener('mouseup', stopDrawing);
    overlayCanvas.addEventListener('mouseout', () => {
      stopDrawing();
      overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
    });

    // For brush preview when cursor enters the canvas
    overlayCanvas.addEventListener('mouseenter', drawBrushPreview);

    // Initial brush preview
    drawBrushPreview();
  </script>
</body>
</html>